(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Phoenix"] = factory();
	else
		root["Phoenix"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/phoenix.js-exposed");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/phoenix.js-exposed":
/*!*******************************!*\
  !*** ./js/phoenix.js-exposed ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {module.exports = global[\"Phoenix\"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib!./phoenix.js */ \"./node_modules/babel-loader/lib/index.js!./js/phoenix.js\");\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://Phoenix/./js/phoenix.js-exposed?");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./js/phoenix.js":
/*!*******************************************************!*\
  !*** ./node_modules/babel-loader/lib!./js/phoenix.js ***!
  \*******************************************************/
/*! exports provided: Channel, Serializer, Socket, LongPoll, Ajax, Presence */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Channel\", function() { return Channel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Serializer\", function() { return Serializer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Socket\", function() { return Socket; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LongPoll\", function() { return LongPoll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ajax\", function() { return Ajax; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Presence\", function() { return Presence; });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Phoenix Channels JavaScript client\n *\n * ## Socket Connection\n *\n * A single connection is established to the server and\n * channels are multiplexed over the connection.\n * Connect to the server using the `Socket` class:\n *\n * ```javascript\n * let socket = new Socket(\"/socket\", {params: {userToken: \"123\"}})\n * socket.connect()\n * ```\n *\n * The `Socket` constructor takes the mount point of the socket,\n * the authentication params, as well as options that can be found in\n * the Socket docs, such as configuring the `LongPoll` transport, and\n * heartbeat.\n *\n * ## Channels\n *\n * Channels are isolated, concurrent processes on the server that\n * subscribe to topics and broker events between the client and server.\n * To join a channel, you must provide the topic, and channel params for\n * authorization. Here's an example chat room example where `\"new_msg\"`\n * events are listened for, messages are pushed to the server, and\n * the channel is joined with ok/error/timeout matches:\n *\n * ```javascript\n * let channel = socket.channel(\"room:123\", {token: roomToken})\n * channel.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\n * $input.onEnter( e => {\n *   channel.push(\"new_msg\", {body: e.target.val}, 10000)\n *     .receive(\"ok\", (msg) => console.log(\"created message\", msg) )\n *     .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\n *     .receive(\"timeout\", () => console.log(\"Networking issue...\") )\n * })\n *\n * channel.join()\n *   .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\n *   .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\n *   .receive(\"timeout\", () => console.log(\"Networking issue. Still waiting...\"))\n *```\n *\n * ## Joining\n *\n * Creating a channel with `socket.channel(topic, params)`, binds the params to\n * `channel.params`, which are sent up on `channel.join()`.\n * Subsequent rejoins will send up the modified params for\n * updating authorization params, or passing up last_message_id information.\n * Successful joins receive an \"ok\" status, while unsuccessful joins\n * receive \"error\".\n *\n * With the default serializers and WebSocket transport, JSON text frames are\n * used for pushing a JSON object literal. If an `ArrayBuffer` instance is provided,\n * binary encoding will be used and the message will be sent with the binary\n * opcode.\n *\n * *Note*: binary messages are only supported on the WebSocket transport.\n *\n * ## Duplicate Join Subscriptions\n *\n * While the client may join any number of topics on any number of channels,\n * the client may only hold a single subscription for each unique topic at any\n * given time. When attempting to create a duplicate subscription,\n * the server will close the existing channel, log a warning, and\n * spawn a new channel for the topic. The client will have their\n * `channel.onClose` callbacks fired for the existing channel, and the new\n * channel join will have its receive hooks processed as normal.\n *\n * ## Pushing Messages\n *\n * From the previous example, we can see that pushing messages to the server\n * can be done with `channel.push(eventName, payload)` and we can optionally\n * receive responses from the push. Additionally, we can use\n * `receive(\"timeout\", callback)` to abort waiting for our other `receive` hooks\n *  and take action after some period of waiting. The default timeout is 10000ms.\n *\n *\n * ## Socket Hooks\n *\n * Lifecycle events of the multiplexed connection can be hooked into via\n * `socket.onError()` and `socket.onClose()` events, ie:\n *\n * ```javascript\n * socket.onError( () => console.log(\"there was an error with the connection!\") )\n * socket.onClose( () => console.log(\"the connection dropped\") )\n * ```\n *\n *\n * ## Channel Hooks\n *\n * For each joined channel, you can bind to `onError` and `onClose` events\n * to monitor the channel lifecycle, ie:\n *\n * ```javascript\n * channel.onError( () => console.log(\"there was an error!\") )\n * channel.onClose( () => console.log(\"the channel has gone away gracefully\") )\n * ```\n *\n * ### onError hooks\n *\n * `onError` hooks are invoked if the socket connection drops, or the channel\n * crashes on the server. In either case, a channel rejoin is attempted\n * automatically in an exponential backoff manner.\n *\n * ### onClose hooks\n *\n * `onClose` hooks are invoked only in two cases. 1) the channel explicitly\n * closed on the server, or 2). The client explicitly closed, by calling\n * `channel.leave()`\n *\n *\n * ## Presence\n *\n * The `Presence` object provides features for syncing presence information\n * from the server with the client and handling presences joining and leaving.\n *\n * ### Syncing state from the server\n *\n * To sync presence state from the server, first instantiate an object and\n * pass your channel in to track lifecycle events:\n *\n * ```javascript\n * let channel = socket.channel(\"some:topic\")\n * let presence = new Presence(channel)\n * ```\n *\n * Next, use the `presence.onSync` callback to react to state changes\n * from the server. For example, to render the list of users every time\n * the list changes, you could write:\n *\n * ```javascript\n * presence.onSync(() => {\n *   myRenderUsersFunction(presence.list())\n * })\n * ```\n *\n * ### Listing Presences\n *\n * `presence.list` is used to return a list of presence information\n * based on the local state of metadata. By default, all presence\n * metadata is returned, but a `listBy` function can be supplied to\n * allow the client to select which metadata to use for a given presence.\n * For example, you may have a user online from different devices with\n * a metadata status of \"online\", but they have set themselves to \"away\"\n * on another device. In this case, the app may choose to use the \"away\"\n * status for what appears on the UI. The example below defines a `listBy`\n * function which prioritizes the first metadata which was registered for\n * each user. This could be the first tab they opened, or the first device\n * they came online from:\n *\n * ```javascript\n * let listBy = (id, {metas: [first, ...rest]}) => {\n *   first.count = rest.length + 1 // count of this user's presences\n *   first.id = id\n *   return first\n * }\n * let onlineUsers = presence.list(listBy)\n * ```\n *\n * ### Handling individual presence join and leave events\n *\n * The `presence.onJoin` and `presence.onLeave` callbacks can be used to\n * react to individual presences joining and leaving the app. For example:\n *\n * ```javascript\n * let presence = new Presence(channel)\n *\n * // detect if user has joined for the 1st time or from another tab/device\n * presence.onJoin((id, current, newPres) => {\n *   if(!current){\n *     console.log(\"user has entered for the first time\", newPres)\n *   } else {\n *     console.log(\"user additional presence\", newPres)\n *   }\n * })\n *\n * // detect if user has left from all tabs/devices, or is still present\n * presence.onLeave((id, current, leftPres) => {\n *   if(current.metas.length === 0){\n *     console.log(\"user has left from all devices\", leftPres)\n *   } else {\n *     console.log(\"user left from a device\", leftPres)\n *   }\n * })\n * // receive presence data from server\n * presence.onSync(() => {\n *   displayUsers(presence.list())\n * })\n * ```\n * @module phoenix\n */\nvar globalSelf = typeof self !== \"undefined\" ? self : null;\nvar phxWindow = typeof window !== \"undefined\" ? window : null;\nvar global = globalSelf || phxWindow || undefined;\nvar DEFAULT_VSN = \"2.0.0\";\nvar SOCKET_STATES = {\n  connecting: 0,\n  open: 1,\n  closing: 2,\n  closed: 3\n};\nvar DEFAULT_TIMEOUT = 10000;\nvar WS_CLOSE_NORMAL = 1000;\nvar CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\"\n};\nvar CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nvar CHANNEL_LIFECYCLE_EVENTS = [CHANNEL_EVENTS.close, CHANNEL_EVENTS.error, CHANNEL_EVENTS.join, CHANNEL_EVENTS.reply, CHANNEL_EVENTS.leave];\nvar TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n}; // wraps value in closure or returns closure\n\nvar closure = function closure(value) {\n  if (typeof value === \"function\") {\n    return value;\n  } else {\n    var _closure = function _closure() {\n      return value;\n    };\n\n    return _closure;\n  }\n};\n/**\n * Initializes the Push\n * @param {Channel} channel - The Channel\n * @param {string} event - The event, for example `\"phx_join\"`\n * @param {Object} payload - The payload, for example `{user_id: 123}`\n * @param {number} timeout - The push timeout in milliseconds\n */\n\n\nvar Push = /*#__PURE__*/function () {\n  function Push(channel, event, payload, timeout) {\n    _classCallCheck(this, Push);\n\n    this.channel = channel;\n    this.event = event;\n\n    this.payload = payload || function () {\n      return {};\n    };\n\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n  /**\n   *\n   * @param {number} timeout\n   */\n\n\n  _createClass(Push, [{\n    key: \"resend\",\n    value: function resend(timeout) {\n      this.timeout = timeout;\n      this.reset();\n      this.send();\n    }\n    /**\n     *\n     */\n\n  }, {\n    key: \"send\",\n    value: function send() {\n      if (this.hasReceived(\"timeout\")) {\n        return;\n      }\n\n      this.startTimeout();\n      this.sent = true;\n      this.channel.socket.push({\n        topic: this.channel.topic,\n        event: this.event,\n        payload: this.payload(),\n        ref: this.ref,\n        join_ref: this.channel.joinRef()\n      });\n    }\n    /**\n     *\n     * @param {*} status\n     * @param {*} callback\n     */\n\n  }, {\n    key: \"receive\",\n    value: function receive(status, callback) {\n      if (this.hasReceived(status)) {\n        callback(this.receivedResp.response);\n      }\n\n      this.recHooks.push({\n        status: status,\n        callback: callback\n      });\n      return this;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.cancelRefEvent();\n      this.ref = null;\n      this.refEvent = null;\n      this.receivedResp = null;\n      this.sent = false;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"matchReceive\",\n    value: function matchReceive(_ref) {\n      var status = _ref.status,\n          response = _ref.response,\n          ref = _ref.ref;\n      this.recHooks.filter(function (h) {\n        return h.status === status;\n      }).forEach(function (h) {\n        return h.callback(response);\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"cancelRefEvent\",\n    value: function cancelRefEvent() {\n      if (!this.refEvent) {\n        return;\n      }\n\n      this.channel.off(this.refEvent);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"cancelTimeout\",\n    value: function cancelTimeout() {\n      clearTimeout(this.timeoutTimer);\n      this.timeoutTimer = null;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"startTimeout\",\n    value: function startTimeout() {\n      var _this = this;\n\n      if (this.timeoutTimer) {\n        this.cancelTimeout();\n      }\n\n      this.ref = this.channel.socket.makeRef();\n      this.refEvent = this.channel.replyEventName(this.ref);\n      this.channel.on(this.refEvent, function (payload) {\n        _this.cancelRefEvent();\n\n        _this.cancelTimeout();\n\n        _this.receivedResp = payload;\n\n        _this.matchReceive(payload);\n      });\n      this.timeoutTimer = setTimeout(function () {\n        _this.trigger(\"timeout\", {});\n      }, this.timeout);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"hasReceived\",\n    value: function hasReceived(status) {\n      return this.receivedResp && this.receivedResp.status === status;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"trigger\",\n    value: function trigger(status, response) {\n      this.channel.trigger(this.refEvent, {\n        status: status,\n        response: response\n      });\n    }\n  }]);\n\n  return Push;\n}();\n/**\n *\n * @param {string} topic\n * @param {(Object|function)} params\n * @param {Socket} socket\n */\n\n\nvar Channel = /*#__PURE__*/function () {\n  function Channel(topic, params, socket) {\n    var _this2 = this;\n\n    _classCallCheck(this, Channel);\n\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = closure(params || {});\n    this.socket = socket;\n    this.bindings = [];\n    this.bindingRef = 0;\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.stateChangeRefs = [];\n    this.rejoinTimer = new Timer(function () {\n      if (_this2.socket.isConnected()) {\n        _this2.rejoin();\n      }\n    }, this.socket.rejoinAfterMs);\n    this.stateChangeRefs.push(this.socket.onError(function () {\n      return _this2.rejoinTimer.reset();\n    }));\n    this.stateChangeRefs.push(this.socket.onOpen(function () {\n      _this2.rejoinTimer.reset();\n\n      if (_this2.isErrored()) {\n        _this2.rejoin();\n      }\n    }));\n    this.joinPush.receive(\"ok\", function () {\n      _this2.state = CHANNEL_STATES.joined;\n\n      _this2.rejoinTimer.reset();\n\n      _this2.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n\n      _this2.pushBuffer = [];\n    });\n    this.joinPush.receive(\"error\", function () {\n      _this2.state = CHANNEL_STATES.errored;\n\n      if (_this2.socket.isConnected()) {\n        _this2.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.onClose(function () {\n      _this2.rejoinTimer.reset();\n\n      if (_this2.socket.hasLogger()) _this2.socket.log(\"channel\", \"close \".concat(_this2.topic, \" \").concat(_this2.joinRef()));\n      _this2.state = CHANNEL_STATES.closed;\n\n      _this2.socket.remove(_this2);\n    });\n    this.onError(function (reason) {\n      if (_this2.socket.hasLogger()) _this2.socket.log(\"channel\", \"error \".concat(_this2.topic), reason);\n\n      if (_this2.isJoining()) {\n        _this2.joinPush.reset();\n      }\n\n      _this2.state = CHANNEL_STATES.errored;\n\n      if (_this2.socket.isConnected()) {\n        _this2.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.joinPush.receive(\"timeout\", function () {\n      if (_this2.socket.hasLogger()) _this2.socket.log(\"channel\", \"timeout \".concat(_this2.topic, \" (\").concat(_this2.joinRef(), \")\"), _this2.joinPush.timeout);\n      var leavePush = new Push(_this2, CHANNEL_EVENTS.leave, closure({}), _this2.timeout);\n      leavePush.send();\n      _this2.state = CHANNEL_STATES.errored;\n\n      _this2.joinPush.reset();\n\n      if (_this2.socket.isConnected()) {\n        _this2.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.on(CHANNEL_EVENTS.reply, function (payload, ref) {\n      _this2.trigger(_this2.replyEventName(ref), payload);\n    });\n  }\n  /**\n   * Join the channel\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n\n\n  _createClass(Channel, [{\n    key: \"join\",\n    value: function join() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.joinedOnce) {\n        throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n      } else {\n        this.timeout = timeout;\n        this.joinedOnce = true;\n        this.rejoin();\n        return this.joinPush;\n      }\n    }\n    /**\n     * Hook into channel close\n     * @param {Function} callback\n     */\n\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n    /**\n     * Hook into channel errors\n     * @param {Function} callback\n     */\n\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      return this.on(CHANNEL_EVENTS.error, function (reason) {\n        return callback(reason);\n      });\n    }\n    /**\n     * Subscribes on channel events\n     *\n     * Subscription returns a ref counter, which can be used later to\n     * unsubscribe the exact event listener\n     *\n     * @example\n     * const ref1 = channel.on(\"event\", do_stuff)\n     * const ref2 = channel.on(\"event\", do_other_stuff)\n     * channel.off(\"event\", ref1)\n     * // Since unsubscription, do_stuff won't fire,\n     * // while do_other_stuff will keep firing on the \"event\"\n     *\n     * @param {string} event\n     * @param {Function} callback\n     * @returns {integer} ref\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      var ref = this.bindingRef++;\n      this.bindings.push({\n        event: event,\n        ref: ref,\n        callback: callback\n      });\n      return ref;\n    }\n    /**\n     * Unsubscribes off of channel events\n     *\n     * Use the ref returned from a channel.on() to unsubscribe one\n     * handler, or pass nothing for the ref to unsubscribe all\n     * handlers for the given event.\n     *\n     * @example\n     * // Unsubscribe the do_stuff handler\n     * const ref1 = channel.on(\"event\", do_stuff)\n     * channel.off(\"event\", ref1)\n     *\n     * // Unsubscribe all handlers from event\n     * channel.off(\"event\")\n     *\n     * @param {string} event\n     * @param {integer} ref\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(event, ref) {\n      this.bindings = this.bindings.filter(function (bind) {\n        return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"canPush\",\n    value: function canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n    /**\n     * Sends a message `event` to phoenix with the payload `payload`.\n     * Phoenix receives this in the `handle_in(event, payload, socket)`\n     * function. if phoenix replies or it times out (default 10000ms),\n     * then optionally the reply can be received.\n     *\n     * @example\n     * channel.push(\"event\")\n     *   .receive(\"ok\", payload => console.log(\"phoenix replied:\", payload))\n     *   .receive(\"error\", err => console.log(\"phoenix errored\", err))\n     *   .receive(\"timeout\", () => console.log(\"timed out pushing\"))\n     * @param {string} event\n     * @param {Object} payload\n     * @param {number} [timeout]\n     * @returns {Push}\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(event, payload) {\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n      payload = payload || {};\n\n      if (!this.joinedOnce) {\n        throw new Error(\"tried to push '\".concat(event, \"' to '\").concat(this.topic, \"' before joining. Use channel.join() before pushing events\"));\n      }\n\n      var pushEvent = new Push(this, event, function () {\n        return payload;\n      }, timeout);\n\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n    /** Leaves the channel\n     *\n     * Unsubscribes from server events, and\n     * instructs channel to terminate on server\n     *\n     * Triggers onClose() hooks\n     *\n     * To receive leave acknowledgements, use the `receive`\n     * hook to bind to the server ack, ie:\n     *\n     * @example\n     * channel.leave().receive(\"ok\", () => alert(\"left!\") )\n     *\n     * @param {integer} timeout\n     * @returns {Push}\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave() {\n      var _this3 = this;\n\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      this.rejoinTimer.reset();\n      this.joinPush.cancelTimeout();\n      this.state = CHANNEL_STATES.leaving;\n\n      var onClose = function onClose() {\n        if (_this3.socket.hasLogger()) _this3.socket.log(\"channel\", \"leave \".concat(_this3.topic));\n\n        _this3.trigger(CHANNEL_EVENTS.close, \"leave\");\n      };\n\n      var leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n      leavePush.receive(\"ok\", function () {\n        return onClose();\n      }).receive(\"timeout\", function () {\n        return onClose();\n      });\n      leavePush.send();\n\n      if (!this.canPush()) {\n        leavePush.trigger(\"ok\", {});\n      }\n\n      return leavePush;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling\n     * before dispatching to the channel callbacks.\n     *\n     * Must return the payload, modified or unmodified\n     * @param {string} event\n     * @param {Object} payload\n     * @param {integer} ref\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event, payload, ref) {\n      return payload;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"isLifecycleEvent\",\n    value: function isLifecycleEvent(event) {\n      return CHANNEL_LIFECYCLE_EVENTS.indexOf(event) >= 0;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"isMember\",\n    value: function isMember(topic, event, payload, joinRef) {\n      if (this.topic !== topic) {\n        return false;\n      }\n\n      if (joinRef && joinRef !== this.joinRef() && this.isLifecycleEvent(event)) {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", \"dropping outdated message\", {\n          topic: topic,\n          event: event,\n          payload: payload,\n          joinRef: joinRef\n        });\n        return false;\n      } else {\n        return true;\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"joinRef\",\n    value: function joinRef() {\n      return this.joinPush.ref;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"rejoin\",\n    value: function rejoin() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.isLeaving()) {\n        return;\n      }\n\n      this.socket.leaveOpenTopic(this.topic);\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"trigger\",\n    value: function trigger(event, payload, ref, joinRef) {\n      var handledPayload = this.onMessage(event, payload, ref, joinRef);\n\n      if (payload && !handledPayload) {\n        throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n      }\n\n      var eventBindings = this.bindings.filter(function (bind) {\n        return bind.event === event;\n      });\n\n      for (var i = 0; i < eventBindings.length; i++) {\n        var bind = eventBindings[i];\n        bind.callback(handledPayload, ref, joinRef || this.joinRef());\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"replyEventName\",\n    value: function replyEventName(ref) {\n      return \"chan_reply_\".concat(ref);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"isClosed\",\n    value: function isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"isErrored\",\n    value: function isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"isJoined\",\n    value: function isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"isJoining\",\n    value: function isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"isLeaving\",\n    value: function isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n  }]);\n\n  return Channel;\n}();\n/* The default serializer for encoding and decoding messages */\n\nvar Serializer = {\n  HEADER_LENGTH: 1,\n  META_LENGTH: 4,\n  KINDS: {\n    push: 0,\n    reply: 1,\n    broadcast: 2\n  },\n  encode: function encode(msg, callback) {\n    if (msg.payload.constructor === ArrayBuffer) {\n      return callback(this.binaryEncode(msg));\n    } else {\n      var payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n      return callback(JSON.stringify(payload));\n    }\n  },\n  decode: function decode(rawPayload, callback) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this.binaryDecode(rawPayload));\n    } else {\n      var _JSON$parse = JSON.parse(rawPayload),\n          _JSON$parse2 = _slicedToArray(_JSON$parse, 5),\n          join_ref = _JSON$parse2[0],\n          ref = _JSON$parse2[1],\n          topic = _JSON$parse2[2],\n          event = _JSON$parse2[3],\n          payload = _JSON$parse2[4];\n\n      return callback({\n        join_ref: join_ref,\n        ref: ref,\n        topic: topic,\n        event: event,\n        payload: payload\n      });\n    }\n  },\n  // private\n  binaryEncode: function binaryEncode(message) {\n    var join_ref = message.join_ref,\n        ref = message.ref,\n        event = message.event,\n        topic = message.topic,\n        payload = message.payload;\n    var metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\n    var header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n    var view = new DataView(header);\n    var offset = 0;\n    view.setUint8(offset++, this.KINDS.push); // kind\n\n    view.setUint8(offset++, join_ref.length);\n    view.setUint8(offset++, ref.length);\n    view.setUint8(offset++, topic.length);\n    view.setUint8(offset++, event.length);\n    Array.from(join_ref, function (char) {\n      return view.setUint8(offset++, char.charCodeAt(0));\n    });\n    Array.from(ref, function (char) {\n      return view.setUint8(offset++, char.charCodeAt(0));\n    });\n    Array.from(topic, function (char) {\n      return view.setUint8(offset++, char.charCodeAt(0));\n    });\n    Array.from(event, function (char) {\n      return view.setUint8(offset++, char.charCodeAt(0));\n    });\n    var combined = new Uint8Array(header.byteLength + payload.byteLength);\n    combined.set(new Uint8Array(header), 0);\n    combined.set(new Uint8Array(payload), header.byteLength);\n    return combined.buffer;\n  },\n  binaryDecode: function binaryDecode(buffer) {\n    var view = new DataView(buffer);\n    var kind = view.getUint8(0);\n    var decoder = new TextDecoder();\n\n    switch (kind) {\n      case this.KINDS.push:\n        return this.decodePush(buffer, view, decoder);\n\n      case this.KINDS.reply:\n        return this.decodeReply(buffer, view, decoder);\n\n      case this.KINDS.broadcast:\n        return this.decodeBroadcast(buffer, view, decoder);\n    }\n  },\n  decodePush: function decodePush(buffer, view, decoder) {\n    var joinRefSize = view.getUint8(1);\n    var topicSize = view.getUint8(2);\n    var eventSize = view.getUint8(3);\n    var offset = this.HEADER_LENGTH + this.META_LENGTH - 1; // pushes have no ref\n\n    var joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    var topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    var event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    var data = buffer.slice(offset, buffer.byteLength);\n    return {\n      join_ref: joinRef,\n      ref: null,\n      topic: topic,\n      event: event,\n      payload: data\n    };\n  },\n  decodeReply: function decodeReply(buffer, view, decoder) {\n    var joinRefSize = view.getUint8(1);\n    var refSize = view.getUint8(2);\n    var topicSize = view.getUint8(3);\n    var eventSize = view.getUint8(4);\n    var offset = this.HEADER_LENGTH + this.META_LENGTH;\n    var joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    var ref = decoder.decode(buffer.slice(offset, offset + refSize));\n    offset = offset + refSize;\n    var topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    var event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    var data = buffer.slice(offset, buffer.byteLength);\n    var payload = {\n      status: event,\n      response: data\n    };\n    return {\n      join_ref: joinRef,\n      ref: ref,\n      topic: topic,\n      event: CHANNEL_EVENTS.reply,\n      payload: payload\n    };\n  },\n  decodeBroadcast: function decodeBroadcast(buffer, view, decoder) {\n    var topicSize = view.getUint8(1);\n    var eventSize = view.getUint8(2);\n    var offset = this.HEADER_LENGTH + 2;\n    var topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    var event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    var data = buffer.slice(offset, buffer.byteLength);\n    return {\n      join_ref: null,\n      ref: null,\n      topic: topic,\n      event: event,\n      payload: data\n    };\n  }\n};\n/** Initializes the Socket\n *\n *\n * For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n *\n * @param {string} endPoint - The string WebSocket endpoint, ie, `\"ws://example.com/socket\"`,\n *                                               `\"wss://example.com\"`\n *                                               `\"/socket\"` (inherited host & protocol)\n * @param {Object} [opts] - Optional configuration\n * @param {string} [opts.transport] - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n *\n * Defaults to WebSocket with automatic LongPoll fallback.\n * @param {Function} [opts.encode] - The function to encode outgoing messages.\n *\n * Defaults to JSON encoder.\n *\n * @param {Function} [opts.decode] - The function to decode incoming messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.parse(payload))\n * ```\n *\n * @param {number} [opts.timeout] - The default timeout in milliseconds to trigger push timeouts.\n *\n * Defaults `DEFAULT_TIMEOUT`\n * @param {number} [opts.heartbeatIntervalMs] - The millisec interval to send a heartbeat message\n * @param {number} [opts.reconnectAfterMs] - The optional function that returns the millsec\n * socket reconnect interval.\n *\n * Defaults to stepped backoff of:\n *\n * ```javascript\n * function(tries){\n *   return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000\n * }\n * ````\n *\n * @param {number} [opts.rejoinAfterMs] - The optional function that returns the millsec\n * rejoin interval for individual channels.\n *\n * ```javascript\n * function(tries){\n *   return [1000, 2000, 5000][tries - 1] || 10000\n * }\n * ````\n *\n * @param {Function} [opts.logger] - The optional function for specialized logging, ie:\n *\n * ```javascript\n * function(kind, msg, data) {\n *   console.log(`${kind}: ${msg}`, data)\n * }\n * ```\n *\n * @param {number} [opts.longpollerTimeout] - The maximum timeout of a long poll AJAX request.\n *\n * Defaults to 20s (double the server long poll timer).\n *\n * @param {{Object|function)} [opts.params] - The optional params to pass when connecting\n * @param {string} [opts.binaryType] - The binary type to use for binary WebSocket frames.\n *\n * Defaults to \"arraybuffer\"\n *\n * @param {vsn} [opts.vsn] - The serializer's protocol version to send on connect.\n *\n * Defaults to DEFAULT_VSN.\n*/\n\nvar Socket = /*#__PURE__*/function () {\n  function Socket(endPoint) {\n    var _this4 = this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Socket);\n\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || global.WebSocket || LongPoll;\n    this.defaultEncoder = Serializer.encode.bind(Serializer);\n    this.defaultDecoder = Serializer.decode.bind(Serializer);\n    this.closeWasClean = false;\n    this.unloaded = false;\n    this.binaryType = opts.binaryType || \"arraybuffer\";\n\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder;\n      this.decode = opts.decode || this.defaultDecoder;\n    } else {\n      this.encode = this.defaultEncoder;\n      this.decode = this.defaultDecoder;\n    }\n\n    if (phxWindow && phxWindow.addEventListener) {\n      phxWindow.addEventListener(\"beforeunload\", function (e) {\n        if (_this4.conn) {\n          _this4.unloaded = true;\n\n          _this4.abnormalClose(\"unloaded\");\n        }\n      });\n    }\n\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000;\n\n    this.rejoinAfterMs = function (tries) {\n      if (opts.rejoinAfterMs) {\n        return opts.rejoinAfterMs(tries);\n      } else {\n        return [1000, 2000, 5000][tries - 1] || 10000;\n      }\n    };\n\n    this.reconnectAfterMs = function (tries) {\n      if (_this4.unloaded) {\n        return 100;\n      }\n\n      if (opts.reconnectAfterMs) {\n        return opts.reconnectAfterMs(tries);\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000;\n      }\n    };\n\n    this.logger = opts.logger || null;\n    this.longpollerTimeout = opts.longpollerTimeout || 20000;\n    this.params = closure(opts.params || {});\n    this.endPoint = \"\".concat(endPoint, \"/\").concat(TRANSPORTS.websocket);\n    this.vsn = opts.vsn || DEFAULT_VSN;\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(function () {\n      _this4.teardown(function () {\n        return _this4.connect();\n      });\n    }, this.reconnectAfterMs);\n  }\n  /**\n   * Returns the socket protocol\n   *\n   * @returns {string}\n   */\n\n\n  _createClass(Socket, [{\n    key: \"protocol\",\n    value: function protocol() {\n      return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n    }\n    /**\n     * The fully qualifed socket url\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: \"endPointURL\",\n    value: function endPointURL() {\n      var uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), {\n        vsn: this.vsn\n      });\n\n      if (uri.charAt(0) !== \"/\") {\n        return uri;\n      }\n\n      if (uri.charAt(1) === \"/\") {\n        return \"\".concat(this.protocol(), \":\").concat(uri);\n      }\n\n      return \"\".concat(this.protocol(), \"://\").concat(location.host).concat(uri);\n    }\n    /**\n     * Disconnects the socket\n     *\n     * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.\n     *\n     * @param {Function} callback - Optional callback which is called after socket is disconnected.\n     * @param {integer} code - A status code for disconnection (Optional).\n     * @param {string} reason - A textual description of the reason to disconnect. (Optional)\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(callback, code, reason) {\n      this.closeWasClean = true;\n      this.reconnectTimer.reset();\n      this.teardown(callback, code, reason);\n    }\n    /**\n     *\n     * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`\n     *\n     * Passing params to connect is deprecated; pass them in the Socket constructor instead:\n     * `new Socket(\"/socket\", {params: {user_id: userToken}})`.\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect(params) {\n      var _this5 = this;\n\n      if (params) {\n        console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n        this.params = closure(params);\n      }\n\n      if (this.conn) {\n        return;\n      }\n\n      this.closeWasClean = false;\n      this.conn = new this.transport(this.endPointURL());\n      this.conn.binaryType = this.binaryType;\n      this.conn.timeout = this.longpollerTimeout;\n\n      this.conn.onopen = function () {\n        return _this5.onConnOpen();\n      };\n\n      this.conn.onerror = function (error) {\n        return _this5.onConnError(error);\n      };\n\n      this.conn.onmessage = function (event) {\n        return _this5.onConnMessage(event);\n      };\n\n      this.conn.onclose = function (event) {\n        return _this5.onConnClose(event);\n      };\n    }\n    /**\n     * Logs the message. Override `this.logger` for specialized logging. noops by default\n     * @param {string} kind\n     * @param {string} msg\n     * @param {Object} data\n     */\n\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n    /**\n     * Returns true if a logger has been set on this socket.\n     */\n\n  }, {\n    key: \"hasLogger\",\n    value: function hasLogger() {\n      return this.logger !== null;\n    }\n    /**\n     * Registers callbacks for connection open events\n     *\n     * @example socket.onOpen(function(){ console.info(\"the socket was opened\") })\n     *\n     * @param {Function} callback\n     */\n\n  }, {\n    key: \"onOpen\",\n    value: function onOpen(callback) {\n      var ref = this.makeRef();\n      this.stateChangeCallbacks.open.push([ref, callback]);\n      return ref;\n    }\n    /**\n     * Registers callbacks for connection close events\n     * @param {Function} callback\n     */\n\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      var ref = this.makeRef();\n      this.stateChangeCallbacks.close.push([ref, callback]);\n      return ref;\n    }\n    /**\n     * Registers callbacks for connection error events\n     *\n     * @example socket.onError(function(error){ alert(\"An error occurred\") })\n     *\n     * @param {Function} callback\n     */\n\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      var ref = this.makeRef();\n      this.stateChangeCallbacks.error.push([ref, callback]);\n      return ref;\n    }\n    /**\n     * Registers callbacks for connection message events\n     * @param {Function} callback\n     */\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(callback) {\n      var ref = this.makeRef();\n      this.stateChangeCallbacks.message.push([ref, callback]);\n      return ref;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"onConnOpen\",\n    value: function onConnOpen() {\n      if (this.hasLogger()) this.log(\"transport\", \"connected to \".concat(this.endPointURL()));\n      this.unloaded = false;\n      this.closeWasClean = false;\n      this.flushSendBuffer();\n      this.reconnectTimer.reset();\n      this.resetHeartbeat();\n      this.stateChangeCallbacks.open.forEach(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n            callback = _ref3[1];\n\n        return callback();\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"heartbeatTimeout\",\n    value: function heartbeatTimeout() {\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n\n        if (this.hasLogger()) {\n          this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n        }\n\n        this.abnormalClose(\"heartbeat timeout\");\n      }\n    }\n  }, {\n    key: \"resetHeartbeat\",\n    value: function resetHeartbeat() {\n      var _this6 = this;\n\n      if (this.conn && this.conn.skipHeartbeat) {\n        return;\n      }\n\n      this.pendingHeartbeatRef = null;\n      clearTimeout(this.heartbeatTimer);\n      setTimeout(function () {\n        return _this6.sendHeartbeat();\n      }, this.heartbeatIntervalMs);\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown(callback, code, reason) {\n      var _this7 = this;\n\n      if (!this.conn) {\n        return callback && callback();\n      }\n\n      this.waitForBufferDone(function () {\n        if (_this7.conn) {\n          if (code) {\n            _this7.conn.close(code, reason || \"\");\n          } else {\n            _this7.conn.close();\n          }\n        }\n\n        _this7.waitForSocketClosed(function () {\n          if (_this7.conn) {\n            _this7.conn.onclose = function () {}; // noop\n\n\n            _this7.conn = null;\n          }\n\n          callback && callback();\n        });\n      });\n    }\n  }, {\n    key: \"waitForBufferDone\",\n    value: function waitForBufferDone(callback) {\n      var _this8 = this;\n\n      var tries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n        callback();\n        return;\n      }\n\n      setTimeout(function () {\n        _this8.waitForBufferDone(callback, tries + 1);\n      }, 150 * tries);\n    }\n  }, {\n    key: \"waitForSocketClosed\",\n    value: function waitForSocketClosed(callback) {\n      var _this9 = this;\n\n      var tries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n        callback();\n        return;\n      }\n\n      setTimeout(function () {\n        _this9.waitForSocketClosed(callback, tries + 1);\n      }, 150 * tries);\n    }\n  }, {\n    key: \"onConnClose\",\n    value: function onConnClose(event) {\n      if (this.hasLogger()) this.log(\"transport\", \"close\", event);\n      this.triggerChanError();\n      clearTimeout(this.heartbeatTimer);\n\n      if (!this.closeWasClean) {\n        this.reconnectTimer.scheduleTimeout();\n      }\n\n      this.stateChangeCallbacks.close.forEach(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            callback = _ref5[1];\n\n        return callback(event);\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"onConnError\",\n    value: function onConnError(error) {\n      if (this.hasLogger()) this.log(\"transport\", error);\n      this.triggerChanError();\n      this.stateChangeCallbacks.error.forEach(function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 2),\n            callback = _ref7[1];\n\n        return callback(error);\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"triggerChanError\",\n    value: function triggerChanError() {\n      this.channels.forEach(function (channel) {\n        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n          channel.trigger(CHANNEL_EVENTS.error);\n        }\n      });\n    }\n    /**\n     * @returns {string}\n     */\n\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return \"connecting\";\n\n        case SOCKET_STATES.open:\n          return \"open\";\n\n        case SOCKET_STATES.closing:\n          return \"closing\";\n\n        default:\n          return \"closed\";\n      }\n    }\n    /**\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === \"open\";\n    }\n    /**\n     * @private\n     *\n     * @param {Channel}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(channel) {\n      this.off(channel.stateChangeRefs);\n      this.channels = this.channels.filter(function (c) {\n        return c.joinRef() !== channel.joinRef();\n      });\n    }\n    /**\n     * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.\n     *\n     * @param {refs} - list of refs returned by calls to\n     *                 `onOpen`, `onClose`, `onError,` and `onMessage`\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(refs) {\n      for (var key in this.stateChangeCallbacks) {\n        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(function (_ref8) {\n          var _ref9 = _slicedToArray(_ref8, 1),\n              ref = _ref9[0];\n\n          return refs.indexOf(ref) === -1;\n        });\n      }\n    }\n    /**\n     * Initiates a new channel for the given topic\n     *\n     * @param {string} topic\n     * @param {Object} chanParams - Parameters for the channel\n     * @returns {Channel}\n     */\n\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var chanParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var chan = new Channel(topic, chanParams, this);\n      this.channels.push(chan);\n      return chan;\n    }\n    /**\n     * @param {Object} data\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this10 = this;\n\n      if (this.hasLogger()) {\n        var topic = data.topic,\n            event = data.event,\n            payload = data.payload,\n            ref = data.ref,\n            join_ref = data.join_ref;\n        this.log(\"push\", \"\".concat(topic, \" \").concat(event, \" (\").concat(join_ref, \", \").concat(ref, \")\"), payload);\n      }\n\n      if (this.isConnected()) {\n        this.encode(data, function (result) {\n          return _this10.conn.send(result);\n        });\n      } else {\n        this.sendBuffer.push(function () {\n          return _this10.encode(data, function (result) {\n            return _this10.conn.send(result);\n          });\n        });\n      }\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     * @returns {string}\n     */\n\n  }, {\n    key: \"makeRef\",\n    value: function makeRef() {\n      var newRef = this.ref + 1;\n\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n  }, {\n    key: \"sendHeartbeat\",\n    value: function sendHeartbeat() {\n      var _this11 = this;\n\n      if (this.pendingHeartbeatRef && !this.isConnected()) {\n        return;\n      }\n\n      this.pendingHeartbeatRef = this.makeRef();\n      this.push({\n        topic: \"phoenix\",\n        event: \"heartbeat\",\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n      this.heartbeatTimer = setTimeout(function () {\n        return _this11.heartbeatTimeout();\n      }, this.heartbeatIntervalMs);\n    }\n  }, {\n    key: \"abnormalClose\",\n    value: function abnormalClose(reason) {\n      this.closeWasClean = false;\n\n      if (this.isConnected()) {\n        this.conn.close(WS_CLOSE_NORMAL, reason);\n      }\n    }\n  }, {\n    key: \"flushSendBuffer\",\n    value: function flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n  }, {\n    key: \"onConnMessage\",\n    value: function onConnMessage(rawMessage) {\n      var _this12 = this;\n\n      this.decode(rawMessage.data, function (msg) {\n        var topic = msg.topic,\n            event = msg.event,\n            payload = msg.payload,\n            ref = msg.ref,\n            join_ref = msg.join_ref;\n\n        if (ref && ref === _this12.pendingHeartbeatRef) {\n          clearTimeout(_this12.heartbeatTimer);\n          _this12.pendingHeartbeatRef = null;\n          setTimeout(function () {\n            return _this12.sendHeartbeat();\n          }, _this12.heartbeatIntervalMs);\n        }\n\n        if (_this12.hasLogger()) _this12.log(\"receive\", \"\".concat(payload.status || \"\", \" \").concat(topic, \" \").concat(event, \" \").concat(ref && \"(\" + ref + \")\" || \"\"), payload);\n\n        for (var i = 0; i < _this12.channels.length; i++) {\n          var channel = _this12.channels[i];\n\n          if (!channel.isMember(topic, event, payload, join_ref)) {\n            continue;\n          }\n\n          channel.trigger(event, payload, ref, join_ref);\n        }\n\n        for (var _i2 = 0; _i2 < _this12.stateChangeCallbacks.message.length; _i2++) {\n          var _this12$stateChangeCa = _slicedToArray(_this12.stateChangeCallbacks.message[_i2], 2),\n              callback = _this12$stateChangeCa[1];\n\n          callback(msg);\n        }\n      });\n    }\n  }, {\n    key: \"leaveOpenTopic\",\n    value: function leaveOpenTopic(topic) {\n      var dupChannel = this.channels.find(function (c) {\n        return c.topic === topic && (c.isJoined() || c.isJoining());\n      });\n\n      if (dupChannel) {\n        if (this.hasLogger()) this.log(\"transport\", \"leaving duplicate topic \\\"\".concat(topic, \"\\\"\"));\n        dupChannel.leave();\n      }\n    }\n  }]);\n\n  return Socket;\n}();\nvar LongPoll = /*#__PURE__*/function () {\n  function LongPoll(endPoint) {\n    _classCallCheck(this, LongPoll);\n\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n\n    this.onopen = function () {}; // noop\n\n\n    this.onerror = function () {}; // noop\n\n\n    this.onmessage = function () {}; // noop\n\n\n    this.onclose = function () {}; // noop\n\n\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n    this.poll();\n  }\n\n  _createClass(LongPoll, [{\n    key: \"normalizeEndpoint\",\n    value: function normalizeEndpoint(endPoint) {\n      return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)\\/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n    }\n  }, {\n    key: \"endpointURL\",\n    value: function endpointURL() {\n      return Ajax.appendParams(this.pollEndpoint, {\n        token: this.token\n      });\n    }\n  }, {\n    key: \"closeAndRetry\",\n    value: function closeAndRetry() {\n      this.close();\n      this.readyState = SOCKET_STATES.connecting;\n    }\n  }, {\n    key: \"ontimeout\",\n    value: function ontimeout() {\n      this.onerror(\"timeout\");\n      this.closeAndRetry();\n    }\n  }, {\n    key: \"poll\",\n    value: function poll() {\n      var _this13 = this;\n\n      if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n        return;\n      }\n\n      Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (resp) {\n        if (resp) {\n          var status = resp.status,\n              token = resp.token,\n              messages = resp.messages;\n          _this13.token = token;\n        } else {\n          var status = 0;\n        }\n\n        switch (status) {\n          case 200:\n            messages.forEach(function (msg) {\n              // Tasks are what things like event handlers, setTimeout callbacks,\n              // promise resolves and more are run within.\n              // In modern browsers, there are two different kinds of tasks,\n              // microtasks and macrotasks.\n              // Microtasks are mainly used for Promises, while macrotasks are\n              // used for everything else.\n              // Microtasks always have priority over macrotasks. If the JS engine\n              // is looking for a task to run, it will always try to empty the\n              // microtask queue before attempting to run anything from the\n              // macrotask queue.\n              //\n              // For the WebSocket transport, messages always arrive in their own\n              // event. This means that if any promises are resolved from within,\n              // their callbacks will always finish execution by the time the\n              // next message event handler is run.\n              //\n              // In order to emulate this behaviour, we need to make sure each\n              // onmessage handler is run within it's own macrotask.\n              setTimeout(function () {\n                _this13.onmessage({\n                  data: msg\n                });\n              }, 0);\n            });\n\n            _this13.poll();\n\n            break;\n\n          case 204:\n            _this13.poll();\n\n            break;\n\n          case 410:\n            _this13.readyState = SOCKET_STATES.open;\n\n            _this13.onopen();\n\n            _this13.poll();\n\n            break;\n\n          case 403:\n            _this13.onerror();\n\n            _this13.close();\n\n            break;\n\n          case 0:\n          case 500:\n            _this13.onerror();\n\n            _this13.closeAndRetry();\n\n            break;\n\n          default:\n            throw new Error(\"unhandled poll status \".concat(status));\n        }\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(body) {\n      var _this14 = this;\n\n      Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), function (resp) {\n        if (!resp || resp.status !== 200) {\n          _this14.onerror(resp && resp.status);\n\n          _this14.closeAndRetry();\n        }\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(code, reason) {\n      this.readyState = SOCKET_STATES.closed;\n      this.onclose();\n    }\n  }]);\n\n  return LongPoll;\n}();\nvar Ajax = /*#__PURE__*/function () {\n  function Ajax() {\n    _classCallCheck(this, Ajax);\n  }\n\n  _createClass(Ajax, null, [{\n    key: \"request\",\n    value: function request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n      if (global.XDomainRequest) {\n        var req = new XDomainRequest(); // IE8, IE9\n\n        this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n      } else {\n        var _req = new global.XMLHttpRequest(); // IE7+, Firefox, Chrome, Opera, Safari\n\n\n        this.xhrRequest(_req, method, endPoint, accept, body, timeout, ontimeout, callback);\n      }\n    }\n  }, {\n    key: \"xdomainRequest\",\n    value: function xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n      var _this15 = this;\n\n      req.timeout = timeout;\n      req.open(method, endPoint);\n\n      req.onload = function () {\n        var response = _this15.parseJSON(req.responseText);\n\n        callback && callback(response);\n      };\n\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      } // Work around bug in IE9 that requires an attached onprogress handler\n\n\n      req.onprogress = function () {};\n\n      req.send(body);\n    }\n  }, {\n    key: \"xhrRequest\",\n    value: function xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n      var _this16 = this;\n\n      req.open(method, endPoint, true);\n      req.timeout = timeout;\n      req.setRequestHeader(\"Content-Type\", accept);\n\n      req.onerror = function () {\n        callback && callback(null);\n      };\n\n      req.onreadystatechange = function () {\n        if (req.readyState === _this16.states.complete && callback) {\n          var response = _this16.parseJSON(req.responseText);\n\n          callback(response);\n        }\n      };\n\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.send(body);\n    }\n  }, {\n    key: \"parseJSON\",\n    value: function parseJSON(resp) {\n      if (!resp || resp === \"\") {\n        return null;\n      }\n\n      try {\n        return JSON.parse(resp);\n      } catch (e) {\n        console && console.log(\"failed to parse JSON response\", resp);\n        return null;\n      }\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(obj, parentKey) {\n      var queryStr = [];\n\n      for (var key in obj) {\n        if (!obj.hasOwnProperty(key)) {\n          continue;\n        }\n\n        var paramKey = parentKey ? \"\".concat(parentKey, \"[\").concat(key, \"]\") : key;\n        var paramVal = obj[key];\n\n        if (_typeof(paramVal) === \"object\") {\n          queryStr.push(this.serialize(paramVal, paramKey));\n        } else {\n          queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n        }\n      }\n\n      return queryStr.join(\"&\");\n    }\n  }, {\n    key: \"appendParams\",\n    value: function appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      var prefix = url.match(/\\?/) ? \"&\" : \"?\";\n      return \"\".concat(url).concat(prefix).concat(this.serialize(params));\n    }\n  }]);\n\n  return Ajax;\n}();\nAjax.states = {\n  complete: 4\n};\n/**\n * Initializes the Presence\n * @param {Channel} channel - The Channel\n * @param {Object} opts - The options,\n *        for example `{events: {state: \"state\", diff: \"diff\"}}`\n */\n\nvar Presence = /*#__PURE__*/function () {\n  function Presence(channel) {\n    var _this17 = this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Presence);\n\n    var events = opts.events || {\n      state: \"presence_state\",\n      diff: \"presence_diff\"\n    };\n    this.state = {};\n    this.pendingDiffs = [];\n    this.channel = channel;\n    this.joinRef = null;\n    this.caller = {\n      onJoin: function onJoin() {},\n      onLeave: function onLeave() {},\n      onSync: function onSync() {}\n    };\n    this.channel.on(events.state, function (newState) {\n      var _this17$caller = _this17.caller,\n          onJoin = _this17$caller.onJoin,\n          onLeave = _this17$caller.onLeave,\n          onSync = _this17$caller.onSync;\n      _this17.joinRef = _this17.channel.joinRef();\n      _this17.state = Presence.syncState(_this17.state, newState, onJoin, onLeave);\n\n      _this17.pendingDiffs.forEach(function (diff) {\n        _this17.state = Presence.syncDiff(_this17.state, diff, onJoin, onLeave);\n      });\n\n      _this17.pendingDiffs = [];\n      onSync();\n    });\n    this.channel.on(events.diff, function (diff) {\n      var _this17$caller2 = _this17.caller,\n          onJoin = _this17$caller2.onJoin,\n          onLeave = _this17$caller2.onLeave,\n          onSync = _this17$caller2.onSync;\n\n      if (_this17.inPendingSyncState()) {\n        _this17.pendingDiffs.push(diff);\n      } else {\n        _this17.state = Presence.syncDiff(_this17.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n  }\n\n  _createClass(Presence, [{\n    key: \"onJoin\",\n    value: function onJoin(callback) {\n      this.caller.onJoin = callback;\n    }\n  }, {\n    key: \"onLeave\",\n    value: function onLeave(callback) {\n      this.caller.onLeave = callback;\n    }\n  }, {\n    key: \"onSync\",\n    value: function onSync(callback) {\n      this.caller.onSync = callback;\n    }\n  }, {\n    key: \"list\",\n    value: function list(by) {\n      return Presence.list(this.state, by);\n    }\n  }, {\n    key: \"inPendingSyncState\",\n    value: function inPendingSyncState() {\n      return !this.joinRef || this.joinRef !== this.channel.joinRef();\n    } // lower-level public static API\n\n    /**\n     * Used to sync the list of presences on the server\n     * with the client's state. An optional `onJoin` and `onLeave` callback can\n     * be provided to react to changes in the client's local presences across\n     * disconnects and reconnects with the server.\n     *\n     * @returns {Presence}\n     */\n\n  }], [{\n    key: \"syncState\",\n    value: function syncState(currentState, newState, onJoin, onLeave) {\n      var _this18 = this;\n\n      var state = this.clone(currentState);\n      var joins = {};\n      var leaves = {};\n      this.map(state, function (key, presence) {\n        if (!newState[key]) {\n          leaves[key] = presence;\n        }\n      });\n      this.map(newState, function (key, newPresence) {\n        var currentPresence = state[key];\n\n        if (currentPresence) {\n          var newRefs = newPresence.metas.map(function (m) {\n            return m.phx_ref;\n          });\n          var curRefs = currentPresence.metas.map(function (m) {\n            return m.phx_ref;\n          });\n          var joinedMetas = newPresence.metas.filter(function (m) {\n            return curRefs.indexOf(m.phx_ref) < 0;\n          });\n          var leftMetas = currentPresence.metas.filter(function (m) {\n            return newRefs.indexOf(m.phx_ref) < 0;\n          });\n\n          if (joinedMetas.length > 0) {\n            joins[key] = newPresence;\n            joins[key].metas = joinedMetas;\n          }\n\n          if (leftMetas.length > 0) {\n            leaves[key] = _this18.clone(currentPresence);\n            leaves[key].metas = leftMetas;\n          }\n        } else {\n          joins[key] = newPresence;\n        }\n      });\n      return this.syncDiff(state, {\n        joins: joins,\n        leaves: leaves\n      }, onJoin, onLeave);\n    }\n    /**\n     *\n     * Used to sync a diff of presence join and leave\n     * events from the server, as they happen. Like `syncState`, `syncDiff`\n     * accepts optional `onJoin` and `onLeave` callbacks to react to a user\n     * joining or leaving from a device.\n     *\n     * @returns {Presence}\n     */\n\n  }, {\n    key: \"syncDiff\",\n    value: function syncDiff(currentState, _ref10, onJoin, onLeave) {\n      var joins = _ref10.joins,\n          leaves = _ref10.leaves;\n      var state = this.clone(currentState);\n\n      if (!onJoin) {\n        onJoin = function onJoin() {};\n      }\n\n      if (!onLeave) {\n        onLeave = function onLeave() {};\n      }\n\n      this.map(joins, function (key, newPresence) {\n        var currentPresence = state[key];\n        state[key] = newPresence;\n\n        if (currentPresence) {\n          var _state$key$metas;\n\n          var joinedRefs = state[key].metas.map(function (m) {\n            return m.phx_ref;\n          });\n          var curMetas = currentPresence.metas.filter(function (m) {\n            return joinedRefs.indexOf(m.phx_ref) < 0;\n          });\n\n          (_state$key$metas = state[key].metas).unshift.apply(_state$key$metas, _toConsumableArray(curMetas));\n        }\n\n        onJoin(key, currentPresence, newPresence);\n      });\n      this.map(leaves, function (key, leftPresence) {\n        var currentPresence = state[key];\n\n        if (!currentPresence) {\n          return;\n        }\n\n        var refsToRemove = leftPresence.metas.map(function (m) {\n          return m.phx_ref;\n        });\n        currentPresence.metas = currentPresence.metas.filter(function (p) {\n          return refsToRemove.indexOf(p.phx_ref) < 0;\n        });\n        onLeave(key, currentPresence, leftPresence);\n\n        if (currentPresence.metas.length === 0) {\n          delete state[key];\n        }\n      });\n      return state;\n    }\n    /**\n     * Returns the array of presences, with selected metadata.\n     *\n     * @param {Object} presences\n     * @param {Function} chooser\n     *\n     * @returns {Presence}\n     */\n\n  }, {\n    key: \"list\",\n    value: function list(presences, chooser) {\n      if (!chooser) {\n        chooser = function chooser(key, pres) {\n          return pres;\n        };\n      }\n\n      return this.map(presences, function (key, presence) {\n        return chooser(key, presence);\n      });\n    } // private\n\n  }, {\n    key: \"map\",\n    value: function map(obj, func) {\n      return Object.getOwnPropertyNames(obj).map(function (key) {\n        return func(key, obj[key]);\n      });\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n  }]);\n\n  return Presence;\n}();\n/**\n *\n * Creates a timer that accepts a `timerCalc` function to perform\n * calculated timeout retries, such as exponential backoff.\n *\n * @example\n * let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *   return [1000, 5000, 10000][tries - 1] || 10000\n * })\n * reconnectTimer.scheduleTimeout() // fires after 1000\n * reconnectTimer.scheduleTimeout() // fires after 5000\n * reconnectTimer.reset()\n * reconnectTimer.scheduleTimeout() // fires after 1000\n *\n * @param {Function} callback\n * @param {Function} timerCalc\n */\n\nvar Timer = /*#__PURE__*/function () {\n  function Timer(callback, timerCalc) {\n    _classCallCheck(this, Timer);\n\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n\n  _createClass(Timer, [{\n    key: \"reset\",\n    value: function reset() {\n      this.tries = 0;\n      clearTimeout(this.timer);\n    }\n    /**\n     * Cancels any previous scheduleTimeout and schedules callback\n     */\n\n  }, {\n    key: \"scheduleTimeout\",\n    value: function scheduleTimeout() {\n      var _this19 = this;\n\n      clearTimeout(this.timer);\n      this.timer = setTimeout(function () {\n        _this19.tries = _this19.tries + 1;\n\n        _this19.callback();\n      }, this.timerCalc(this.tries + 1));\n    }\n  }]);\n\n  return Timer;\n}();\n\n//# sourceURL=webpack://Phoenix/./js/phoenix.js?./node_modules/babel-loader/lib");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://Phoenix/(webpack)/buildin/global.js?");

/***/ })

/******/ });
});